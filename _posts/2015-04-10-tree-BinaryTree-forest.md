---
layout: post
title: "tree-BinaryTree-forest"
description: ""
category: data_structure
tags: []
---

##树转换成二叉树

1. 加线。在所有兄弟结点之间加一条连线
2. 去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。
3. 层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。**注意第一个孩子是二叉树结点的左子树，兄弟转换过来的孩子是结点的右孩子。** 这是容易犯错的弄错左右孩子的关系。

##森林转换成二叉树

森林是由若干棵树组成的，所以完全可以理解为，森林中的每一棵树都是兄弟，可以按照兄弟的处理办法来操作。

1. 把每个树转换成为二叉树
2. 第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根节点作为前一棵二叉树的根节点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了有森林转换过来的二叉树。

##二叉树转换为树

二叉树转换成为树是树转换为二叉树的逆过程，也就是反过来做而已。

1. 加线。若某结点的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子。。。，反正就是左孩子的n个右孩子结点都作为此结点的孩子。将该结点与这些右孩子结点用线连接起来。
2. 去线。删除原二叉树中所有结点与其右孩子结点的连线。
3. 层次调整。

##二叉树转换为森林

判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是只要看这棵二叉树的根结点有没有右孩子，有就是可以转换为森林，没有就可以转换为树。

1. 从根节点开始，若右孩子存在，则把与右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除。。。，直到所有右孩子连线都删除为止，得到分离的二叉树。
2. 再将每棵分离后的二叉树转换为树即可。

##树的遍历

1. 深度优先遍历（先根次序遍历和后根次序遍历）。**先根次序遍历**：先访问根节点，然后依次先根遍历根的各棵子树。**后根次序遍历**：先依次后根遍历根的各棵子树，然后访问根节点。
2. 广度优先遍历（层序遍历）：是分层进行的访问

##森林的遍历

其实也分为

1. 深度优先遍历（先根次序遍历和后根次序遍历）。**先根次序遍历**：若森林为空，返回；否则访问F的第一棵树的根节点，然后先根次序遍历第一棵树的子树森林，最后先根次序遍历其他树组成的森林。**后根次序遍历**：若森林为空，返回；否则中根次序遍历F的第一棵树的子树森林，然后访问F的第一棵树的根节点，中根次序遍历其他树组成的森林。
2. 广度优先遍历（层序遍历）：很少用到